
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.2.2, mkdocs-material-7.2.6">
    
    
      
        <title>从 BPF 到 eBPF - pwn2death</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.802231af.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.3f5d1f46.min.css">
        
      
    
    
    
      
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>:root{--md-text-font-family:"Roboto";--md-code-font-family:"Roboto Mono"}</style>
      
    
    
    
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/github.min.css">
    
      <link rel="stylesheet" href="../css/list-marker.css">
    
    
      


    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="none" data-md-color-accent="none">
  
    
    <script>function __prefix(e){return new URL("..",location).pathname+"."+e}function __get(e,t=localStorage){return JSON.parse(t.getItem(__prefix(e)))}</script>
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#bpf-ebpf" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="pwn2death" class="md-header__button md-logo" aria-label="pwn2death" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            pwn2death
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              从 BPF 到 eBPF
            
          </span>
        </div>
      </div>
    </div>
    
    
    
    
  </nav>
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="pwn2death" class="md-nav__button md-logo" aria-label="pwn2death" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    pwn2death
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
      </a>
    </li>
  

    
      
      
      

  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          从 BPF 到 eBPF
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        从 BPF 到 eBPF
      </a>
      
        
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#cspf" class="md-nav__link">
    CSPF
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bpf" class="md-nav__link">
    BPF
  </a>
  
    <nav class="md-nav" aria-label="BPF">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    指令集
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    早期实现
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jit" class="md-nav__link">
    JIT 编译器
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ebpf" class="md-nav__link">
    eBPF
  </a>
  
    <nav class="md-nav" aria-label="eBPF">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    虚拟机
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    指令集
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#map" class="md-nav__link">
    Map
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    文件系统
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    主程序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    过程调用
  </a>
  
    <nav class="md-nav" aria-label="过程调用">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#helper-call" class="md-nav__link">
    helper call
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tail-call" class="md-nav__link">
    tail call
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bpf2bpf-call" class="md-nav__link">
    bpf2bpf call
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    用户空间接口
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#verifier" class="md-nav__link">
    Verifier
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../kernel-debugging-qemu-busybox-gdb/" class="md-nav__link">
        gdb 调试内核
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../kernel-fuzzer-syzkaller/" class="md-nav__link">
        使用 Syzkaller
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../syscall-execution/" class="md-nav__link">
        执行系统调用
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../root-filesystem/" class="md-nav__link">
        根文件系统
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../kernel-security-principle/" class="md-nav__link">
        内核安全机制设计思路
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../ptmalloc2/" class="md-nav__link">
        ptmalloc2
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../heap-exp-house-of-xxx/" class="md-nav__link">
        堆利用：House Of 系列
      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#cspf" class="md-nav__link">
    CSPF
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bpf" class="md-nav__link">
    BPF
  </a>
  
    <nav class="md-nav" aria-label="BPF">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    指令集
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    早期实现
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jit" class="md-nav__link">
    JIT 编译器
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ebpf" class="md-nav__link">
    eBPF
  </a>
  
    <nav class="md-nav" aria-label="eBPF">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    虚拟机
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    指令集
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#map" class="md-nav__link">
    Map
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    文件系统
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    主程序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    过程调用
  </a>
  
    <nav class="md-nav" aria-label="过程调用">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#helper-call" class="md-nav__link">
    helper call
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tail-call" class="md-nav__link">
    tail call
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bpf2bpf-call" class="md-nav__link">
    bpf2bpf call
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    用户空间接口
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#verifier" class="md-nav__link">
    Verifier
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                
                
                <h1 id="bpf-ebpf">从 BPF 到 eBPF</h1>
<p>Berkeley 包过滤器（Berkeley Packet Filter，BPF）是一种基于虚拟机（pseudo machine）的过滤机制，在 92 年 Berkeley 的论文 <a href="http://www.tcpdump.org/papers/bpf-usenix93.pdf">The BSD Packet Filter</a> 中提出。论文原型在 BSD 上实现，所以将其命名为 BPF，但随着 BPF 被各大 OS 接受，B 的含义也从 BSD 逐渐变成 Berkeley。</p>
<p>BPF 本来是为网络数据包过滤设计，但由于方案优越，现已成长为内核的独立子系统 <a href="https://elixir.bootlin.com/linux/v5.13/source/kernel/bpf">/kernel/bpf</a>，广泛用于流量控制、跟踪、性能监控/调优等领域。</p>
<p>eBPF（extended BPF）将 BPF 的虚拟机从 32 位扩展到 64 位，重新设计指令集，引入 map 机制与用户空间通信，极大地拓宽了 BPF 的适用场景。</p>
<p>eBPF 提出后，原先的 BPF 改称 cBPF（classic BPF）以示区分。现在的内核使用 eBPF，但允许用户空间传入 cBPF 程序，内核负责将其转换为 eBPF 格式。</p>
<h2 id="cspf">CSPF</h2>
<p>BPF 之前，主流包过滤方案是 87 年提出的 <a href="https://dl.acm.org/doi/pdf/10.1145/37499.37505">CMU/Stanford Packet Filter</a>，CSPF。当时内核网络栈还不成熟，包过滤普遍放在用户进程做。CSPF 给出了在内核进行包过滤的有效方案。</p>
<p>包过滤即根据字段的取值响应数据包，丢弃或分发到相应的处理进程。核心是布尔表达式求值，如过滤 TCP 包，关键是对表达式 ether.type == IP &amp;&amp; ip.proto == TCP 求值。</p>
<p>CSPF 设计了一个虚拟机，在内核运行，负责解释执行用户空间传入的过滤规则，即用 CSPF 指令序列描述的布尔表达式。CSPF 的指令集非常简单，每条指令包含一个栈操作和一个二元运算：栈操作要么压入一个立即数，要么压入包的第 n 个字（16 位）；二元运算可以是大小比较或者逻辑运算。指令执行时，先进行栈操作，然后出栈两个操作数进行二元运算，结果入栈。最终栈顶元素即为布尔表达式的值。</p>
<p>CSPF 数据宽度只有 16 位，对于 32 位的数据，如 IP 地址，要分两次计算；访问以字为单位，奇数长度的数据包最后一个字节无法访问。这些问题可以通过简单扩展指令集解决。但 CSPF 的根本局限在于，将布尔表达式抽象为二叉树，基于栈自底向上进行求解，这意味着：</p>
<ul>
<li>不支持短路，导致求解不必要的分支；</li>
<li>不支持单元运算，如间接运算，因此无法处理变长头部；</li>
<li>指令集必须围绕栈操作设计，效率上无法支撑复杂逻辑。</li>
</ul>
<p>CSPF 方案有两点尤其值得借鉴：</p>
<ul>
<li>将数据包视作字节数组，过滤机制的设计独立于具体协议，用户程序负责定义过滤规则；</li>
<li>用虚拟机做过滤，可扩展性极强。</li>
</ul>
<p>这两点为 BPF 所继承，奠定了 BPF 成功的基础。BPF 能发展出如今的通用性，CSPF 功不可没。</p>
<h2 id="bpf">BPF</h2>
<p>BPF 在 CSPF 的基础上做了两大改进：</p>
<ul>
<li>将布尔表达式抽象为控制流图，短路不必要的分支求解；</li>
<li>改用基于寄存器的虚拟机，更加灵活。例如，可以在寄存器中动态计算偏移，处理变长头部。</li>
</ul>
<p>BPF 将布尔表达式抽象为有向无环的控制流图（CFG），本质是一个特殊的有限状态机。CFG 由若干非叶节点和两个叶子节点 true 和 false 组成。每个非叶节点对应一次谓词判断，有且仅有 true 和 false 两个分支。从入度为 0 的节点向下计算，最终到达叶子节点，得到表达式的值。</p>
<p>BPF 使用基于寄存器的虚拟机实现，字长 32 位，包括：</p>
<ul>
<li>一个 32 位累加器 A；</li>
<li>一个 32 位索引寄存器 X；</li>
<li>一小段随机存储 M[]，由 16 个 32 位寄存器组成，从 0 开始索引；</li>
<li>一个隐含的 PC 寄存器。</li>
</ul>
<h3 id="_1">指令集</h3>
<p>BPF 指令长度固定为 64 位，由四个字段组成：</p>
<pre><code class="language-txt">opcode:16, jt:8, jf:8, k:32
</code></pre>
<p>jt 和 jf 对应 true 和 false 分支下的跳转目标，采用相对跳转。k 为通用存储。opcode 分为以下几类：</p>
<ul>
<li>Load 类，加载数据到 A 或 X，包括立即数、包数据、包长度或 M 中的数据；</li>
<li>Store 类，将 A 或 X 中的数据存储到 M；</li>
<li>ALU 类，算术/逻辑运算，源为 X 或立即数，目的为 A；</li>
<li>Branch 类，比较 A 与 X 或立即数，相应跳转到 jt 或 jf；</li>
<li>Return 类，返回接受的数据长度，为 0 表示丢弃整个数据包；</li>
<li>Misc 类，加载 A 到 X 或加载 X 到 A。</li>
</ul>
<p>该指令集提供相当完备的包过滤能力。例如，按 TCP 目的端口号进行过滤，这需要处理可变长度的 IP 头：</p>
<pre><code class="language-x86asm">ldh [12]                    ; link layer type
jeq #ETHERPROTO_IP, L1, L5
L1: ldb [23]                ; IP protocol type
jeq #IPPROTO_TCP, L2, L5
L2: ldh [20]                ; flag | fragment offset
jset #0x1fff, L5, L3        ; check the fragment offset, reject if non-zero
L3:ldb [14]                 ; version | header length
and #0xf                    ; header length, with word offset
lsh #2                      ; scale by four, get the byte offset
tax
ldh [x+16]                  ; TCP destination port
jeq #N, L1, L2
L4: ret #TRUE               ; non-zero value indicating # of bytes to save
L5: ret #0                  ; reject the packet
</code></pre>
<p><code>ldb/ldh [k]</code> 加载数据包 k 字节偏移处的 byte/halfword 到 A；<code>#k, Lt, Lf</code> 在谓词为 true/false 时跳转到 Lt/Lf，<code>jeq</code> 相等为 true，<code>jset</code> 计算 A &amp; k，非零为 true；<code>tax</code> 加载 A 到 X。</p>
<h3 id="_2">早期实现</h3>
<p>BPF 最早的内核实现是 2.1.75 版本的 <a href="https://elixir.bootlin.com/linux/2.1.75/source/net/core/filter.c">/net/core/filter.c</a>，只有三个函数：</p>
<ul>
<li><a href="https://elixir.bootlin.com/linux/2.1.75/source/net/core/filter.c#L46">sk_run_filter()</a>，在 <a href="https://elixir.bootlin.com/linux/2.1.75/source/include/linux/skbuff.h#L105">skb-&gt;data</a> 上运行过滤器，即 BPF 指令（<a href="https://elixir.bootlin.com/linux/2.1.75/source/include/linux/filter.h#L19">sock_filter</a>）序列，返回截断长度；</li>
<li><a href="https://elixir.bootlin.com/linux/2.1.75/source/net/core/filter.c#L266">sk_chk_filter()</a>，验证过滤器，跳转指令不能越界，对 M[] 的访问不能越界，必须以 ret 结尾；</li>
<li><a href="https://elixir.bootlin.com/linux/2.1.75/source/net/core/filter.c#L333">sk_attach_filter()</a>，附加过滤器到指定 socket，即验证并拷贝用户 <a href="https://elixir.bootlin.com/linux/2.1.75/source/net/core/sock.c#L330">通过 setsockopt() 传入</a> 的过滤器到 kmalloc() 的内存，让 <a href="https://elixir.bootlin.com/linux/2.1.75/source/include/net/sock.h#L462">sk-&gt;filter_data</a> 指向该区域。之后 <a href="https://elixir.bootlin.com/linux/2.1.75/source/include/net/sock.h#L885">sock_queue_rcv_skb()</a> 在该 socket 上接收到数据时，会先运行过滤器进行截断，如果没有完全丢弃，再调用 <a href="https://elixir.bootlin.com/linux/2.1.75/source/include/net/sock.h#L551">sk-&gt;data_ready()</a> 通知上层应用。</li>
</ul>
<p>这时只支持在指令中使用包长度 skb-&gt;len。后来逐渐扩展到 skb-&gt;protocol/hash 等，还支持生成随机数，方便包采样。这部分扩展称作 <a href="https://www.kernel.org/doc/html/latest/networking/filter.html#bpf-engine-and-instruction-set">BPF extensions</a>。</p>
<h3 id="jit">JIT 编译器</h3>
<p>内核 3.0 引入 x86 下的 JIT 编译器 <a href="https://elixir.bootlin.com/linux/v3.0/source/arch/x86/net/bpf_jit_comp.c#L121">bpf_jit_compile()</a>，将 BPF 指令序列编译为 native code：</p>
<ul>
<li>A 翻译为 EAX；X 翻译为 EBX；M 在栈上分配，M[k] 翻译为 RBP-0x10-k*4；</li>
<li>skb 的地址通过 RDI 传入；返回值放 EAX；</li>
<li>编译有 10 个重复 pass，主要是为了向前看，确定是否需要保存 RBX/分配 M/引用 skb 内容；</li>
<li>如果本 pass 与上一 pass 生成的 native code 长度相同，表明编译成功，放入 module_alloc() 的内存中；如果始终不收敛，放弃编译；</li>
<li>通过 <a href="https://elixir.bootlin.com/linux/v3.0/source/include/linux/filter.h#L163">SK_RUN_FILTER</a> 宏调用 <a href="https://elixir.bootlin.com/linux/v3.0/source/include/linux/filter.h#L142">sk_filter-&gt; bpf_func</a>，如果编译成功，该函数指针指向生成的 native code，否则指向 <a href="https://elixir.bootlin.com/linux/v3.0/source/net/core/filter.c#L112">sk_run_filter()</a>。</li>
</ul>
<p>函数指针 bpf_func 让 BPF 可以方便地迁移到其他场景，不再局限于 socket 上的过滤。内核 3.4 起，BPF 应用于系统调用的过滤 <a href="../todo">seccomp</a>。</p>
<h2 id="ebpf">eBPF</h2>
<p>eBPF 最开始是作为一种中间表示在 3.15 引入，使用全新的指令集。BPF 程序加载到内核时，优先进行 JIT 编译，如果编译失败，则调用 <a href="https://elixir.bootlin.com/linux/v3.15/source/net/core/filter.c#L863">sk_convert_filter()</a> 将其转化为中间表示，之后通过 <a href="https://elixir.bootlin.com/linux/v3.15/source/net/core/filter.c#L141">__sk_run_filter()</a> 运行。</p>
<p>到 3.16，这一中间表示正式更名为 eBPF，对应的 JIT 编译器 <a href="https://elixir.bootlin.com/linux/v3.16/source/arch/x86/net/bpf_jit_comp.c#L869">bpf_int_jit_compile()</a> 也一并引入。原来的 BPF 改名 cBPF，对应的 JIT 编译器不再使用。</p>
<p>3.17 开始，eBPF 成为内核独立子系统 /kernel/bpf。3.18 引入系统调用 bpf()，eBPF 框架基本成型，之后逐渐应用至流量控制（<a href="https://docs.cilium.io/en/v1.10/bpf/#xdp">XDP</a>，<a href="https://docs.cilium.io/en/v1.10/bpf/#tc-traffic-control">tc</a>）、跟踪（tracepoint，k/uprobe）、性能监控/调优（perf_event）等领域。</p>
<h3 id="_3">虚拟机</h3>
<p>引入 eBPF 的初衷是向上提供易用的高级语言接口，向下配合 64 位架构，提高执行效率。构想是在用户空间用 C 编写，GCC/LLVM 编译时优化，eBPF 指令自然地映射为 native code 以降低 JIT 编译开销。</p>
<p>为此，eBPF 虚拟机在 BPF 的基础上做了如下改进：</p>
<ul>
<li>寄存器增加到 11 个，R0-R10；</li>
<li>寄存器宽度扩展到 64 位，低 32 位可以作为子寄存器单独访问，写时零扩展到 64 位；</li>
<li>指令集重新设计，允许过程调用 BPF_CALL。</li>
</ul>
<p>过程调用的调用约定：</p>
<ul>
<li>R0-R5 为 caller-saved，R1-R5 传参，R0 放返回值；</li>
<li>R6-R9 为 callee-saved；</li>
<li>R10 为只读的帧指针。</li>
</ul>
<p>该调用约定是为了配合 CPU 架构。以 x64 架构为例，6 个参数寄存器，6 个 callee-saved 寄存器，因此 eBPF 寄存器能一对一映射到 CPU 寄存器，BPF_CALL 指令可以直接 JIT 编译为 call 指令：</p>
<ul>
<li>R0 映射为 RAX;</li>
<li>R1-R5 映射为 RDI，RSI，RDX，RCX，R8；</li>
<li>R6-R9 映射为 RBX，R13，R14，R15；</li>
<li>R10 映射为 RBP。</li>
</ul>
<h3 id="_4">指令集</h3>
<p>eBPF 指令集按 RISC 架构设计，指令长度和 BPF 一样，固定为 64 位，但重新设计了编码方式：</p>
<pre><code class="language-txt">opcode:8, dst_reg:4, src_reg:4, off:16, imm:32
</code></pre>
<p>16 位 opcode 空间太大，缩减为 8 位。目的 dst_reg 和源 src_reg 显式指明，方便 JIT 编译。off 用于内存操作数的寻址。通用存储 imm，即 cBPF 指令的 k，保持 32 位不变。</p>
<p>新编码用单分支 jt/fall-through 替代了双分支 jt/jf：</p>
<ul>
<li>单分支性能更优。对于解释执行，两种方式性能差不多，但对于 JIT 编译，jt/fall-through 可以自然地编译为一次条件跳转，jt/jf 则需要一次条件跳转加一次无条件跳转；</li>
<li>单分支更符合过滤器需要的语义。双分支在过滤器中实际用得很少，经常是让 jf 分支指向下一条指令，当成 jt/fall-through 使用。</li>
</ul>
<p>opcode 在 cBPF 基础上扩展，尽量复用其编码，以便后向兼容：</p>
<ul>
<li>Load/Store 类，规范寻址模式，附带支持少量原子运算；</li>
<li>ALU 类，增加 BPF_MOV 指令，符号扩展的右移运算，以及大小端转换；</li>
<li>JMP 类，完善条件跳转，增加 BPF_CALL 和 BPF_EXIT 指令。</li>
</ul>
<p>对于 Load/Store 类指令，opcode 还编码了 size 和 mode。size 为操作宽度，可选 1/2/4/8 字节。mode 对指令进一步分类：</p>
<ul>
<li>BPF_MEM，常规存取指令，在内存和寄存器间移动数据，或存储 32 位立即数到内存；</li>
<li>BPF_ATOMIC，原子更新目的内存，支持 add/and/or/xor/xchg/cmpxchg 运算；</li>
<li>BPF_IMM，加载 64 位立即数到寄存器，高 32 位占用下一条指令的 imm 字段存储。</li>
</ul>
<p>BPF_ATOMIC 仅用于 Store 类指令，操作宽度限于 4/8 字节。源操作数必须是 src_reg，不能是立即数。运算类型借用 imm 字段存储。</p>
<p>BPF_IMM 仅用于 BPF_LD 指令，操作宽度必须是 8 字节。可用于加载 map 地址、map 数据、BTF 变量地址或 eBPF 函数地址，src_reg 字段需相应设置为 BPF_PSEUDO_{<a href="https://elixir.bootlin.com/linux/v5.13/source/include/uapi/linux/bpf.h#L1108">MAP_FD</a>、<a href="https://elixir.bootlin.com/linux/v5.13/source/include/uapi/linux/bpf.h#L1117">MAP_VALUE</a>、<a href="https://elixir.bootlin.com/linux/v5.13/source/include/uapi/linux/bpf.h#L1127">BTF_ID</a>、<a href="https://elixir.bootlin.com/linux/v5.13/source/include/uapi/linux/bpf.h#L1136">FUNC</a>}。</p>
<p>对于 ALU 类和 JMP 类指令，opcode 用 1 bit 的 src 指示源操作数是 src_reg 还是 imm。BPF_MOV 寻址模式有限，仅在寄存器间移动数据，或加载 32 位立即数到寄存器，因此不完全对应 mov 指令。</p>
<h3 id="map">Map</h3>
<p>eBPF map 是位于内核的 Key-Value 存储，eBPF 程序借此与用户空间通信：
- 用户进程通过系统调用 bpf() 管理 map 并访问其数据；
- 运行在内核的 eBPF 程序通过 helper 函数访问 map 数据。</p>
<p>Map 类似一个 Key-Value 版本的 <a href="../todo">VFS</a>，底层有不同类型（<a href="https://elixir.bootlin.com/linux/v5.13/source/include/uapi/linux/bpf.h#L867">bpf_map_type</a>）的实现。基本类型是数组和哈希表，可以当槽用，如：</p>
<ul>
<li><a href="https://elixir.bootlin.com/linux/v5.13/source/kernel/bpf/arraymap.c#L1087">PROG_ARRAY</a> 存储 eBPF 程序的地址，用于 tail call；</li>
<li><a href="https://elixir.bootlin.com/linux/v5.13/source/kernel/bpf/arraymap.c#L1317">ARRAY_OF_MAPS</a>/<a href="https://elixir.bootlin.com/linux/v5.13/source/kernel/bpf/hashtab.c#L2231">HASH_OF_MAPS</a> 存储 map 的地址。</li>
</ul>
<p>另外有 <a href="https://elixir.bootlin.com/linux/v5.13/source/kernel/bpf/lpm_trie.c#L721">LPM_TRIE</a> 实现了 trie 树，可用于路由转发等前缀匹配场景。各类型 map 的可用操作不完全相同，通过结构体 <a href="https://elixir.bootlin.com/linux/v5.13/source/include/linux/bpf.h#L61">bpf_map_ops</a> 声明。按 key 查找、更新和删除这三个核心操作需要请求 <a href="../todo">RCU 锁</a>。</p>
<h3 id="_5">文件系统</h3>
<p>创建 map 即生成一个 <a href="../todo">匿名 inode</a> 并返回其文件描述符 fd，之后用户进程通过 fd 操作 map。一旦 fd 关闭，对应 map 就会丢失。为了延长 map 的生命周期，让不同进程能共享该 map，允许将其写入一个内存文件系统，供之后的进程访问。</p>
<p>该文件系统在 <a href="https://elixir.bootlin.com/linux/v5.13/source/kernel/bpf/inode.c">inode.c</a> 中定义，支持软硬链接，默认挂载点 /sys/fs/bpf，读写操作封装为 bpf() 命令：</p>
<ul>
<li>BPF_OBJ_PIN，将 fd 对应的 map 写入文件系统，即将匿名 inode 关联到某个路径；</li>
<li>BPF_OBJ_GET，从对应路径取出 map。</li>
</ul>
<p>eBPF 程序也一样，加载到内核时生成 fd，通过写入文件系统分享给其他进程。用户进程总是通过 fd 访问 eBPF 程序/map，内核负责将其解析为具体地址：</p>
<ul>
<li>写 eBPF 程序/map 地址到相应类型的 map：<a href="https://elixir.bootlin.com/linux/v5.13/source/kernel/bpf/arraymap.c#L759">bpf_fd_array_map_update_elem()</a> 负责取得具体地址，用户进程只用传 fd 给 bpf()；</li>
<li>加载 map 地址到寄存器：Verifier 在 <a href="https://elixir.bootlin.com/linux/v5.13/source/kernel/bpf/verifier.c#L11220">resolve_pseudo_ldimm64()</a> 时，将 <a href="https://elixir.bootlin.com/linux/v5.13/source/include/linux/filter.h#L202">BPF_LD_MAP_FD</a> 指令中的 fd 重写为 map 地址。编写 eBPF 程序时只用给出目标 map 的 fd。 </li>
</ul>
<h3 id="_6">主程序</h3>
<p>eBPF 程序有特定的类型 <a href="https://elixir.bootlin.com/linux/v5.13/source/include/uapi/linux/bpf.h#L908">bpf_prog_type</a>，通过 <a href="https://elixir.bootlin.com/linux/v5.13/source/kernel/bpf/syscall.c#L2079">bpf_prog_load()</a> 加载到内核 vmalloc() 的内存，然后通过 setsockopt() 等方式附加到特定数据结构。部分类型，主要是 <a href="../todo">cgroup</a> 相关，附加操作没有用户空间接口，对此 bpf() 提供 BPF_PROG_ATTACH 命令，可附加 eBPF 程序到 <a href="https://elixir.bootlin.com/linux/v5.13/source/include/uapi/linux/bpf.h#L942">bpf_attach_type</a> 中指示的数据结构。</p>
<p>eBPF 程序通过 <a href="https://elixir.bootlin.com/linux/v5.13/source/include/linux/filter.h#L570">bpf_prog-&gt;bpf_func</a> 执行：</p>
<ul>
<li>优先 JIT 编译 <a href="https://elixir.bootlin.com/linux/v5.13/source/arch/x86/net/bpf_jit_comp.c#L2207">bpf_int_jit_compile()</a> 执行，此时 bpf_func 指向 image，即生成的 native code；</li>
<li>如果无法编译执行，通过 <a href="https://elixir.bootlin.com/linux/v5.13/source/kernel/bpf/core.c#L1369">___bpf_prog_run()</a> 执行，此时 bpf_func 指向解释器 <a href="https://elixir.bootlin.com/linux/v5.13/source/kernel/bpf/core.c#L1740">interpreters</a>。</li>
</ul>
<p>相关内核变量 bpf_jit_enable，内核选项 CONFIG_{BPF_JIT、BPF_JIT_ALWAYS_ON、HAVE_EBPF_JIT}。
JIT 编译只要可用，就会应用在所有过滤器上，没有类似 JVM 的 hotspot 机制。目前主流架构都支持 JIT 编译，但对高级特性如 bpf2bpf call 的支持还不成熟。</p>
<p>bpf_func 接收两个参数 ctx 和 insn。ctx 为 void 指针，指向待过滤数据，根据 eBPF 程序类型解析为不同数据结构，如 skb，参见 <a href="https://elixir.bootlin.com/linux/v5.13/source/include/linux/bpf_types.h">bpf_types.h</a>。insn 指向 eBPF 指令序列，仅用于解释执行。JIT 编译执行时，ctx 通过 CPU 寄存器自然传递，如 x86 的 RDI。解释执行时，解释器会先 <a href="https://elixir.bootlin.com/linux/v5.13/source/kernel/bpf/core.c#L1702">将 ctx 放入 R1</a>。</p>
<p>eBPF 程序通过 BPF_EXIT 指令退出，退出前必须显式保存返回值到 R0。解释器遇到 BPF_EXIT 指令直接返回 R0 即可。x64 的 JIT 编译器仍使用帧指针 RBP，因此，对于 BPF_EXIT 需先发射 leave 指令再 ret。</p>
<h3 id="_7">过程调用</h3>
<p>eBPF 使用 BPF_CALL 指令进行过程调用，最多五个参数，ctx 始终通过 RDI/R1 传递：</p>
<ul>
<li>调用特定的 helper 函数；</li>
<li>tail call，调用另一个 eBPF 程序，类型必须相同，调用后不返回；</li>
<li>bpf2bpf call，调用 eBPF 函数，调用后返回到下一条指令。</li>
</ul>
<h4 id="helper-call">helper call</h4>
<p>helper 函数使用 <a href="https://elixir.bootlin.com/linux/v5.13/source/include/linux/filter.h#L486">BPF_CALL_x</a> 宏定义，通过 <a href="https://elixir.bootlin.com/linux/v5.13/source/include/uapi/linux/bpf.h#L4912">bpf_func_id</a> 标识，用于访问 map 数据或者操作特定数据结构，如读写 skb。helper 函数预先定义在内核，不能动态装卸，只能重新编译内核。</p>
<p>定义 helper 函数需提供原型描述 <a href="https://elixir.bootlin.com/linux/v5.13/source/include/linux/bpf.h#L337">bpf_func_proto</a>，以及 func_id 到 func_proto 的映射 <a href="https://elixir.bootlin.com/linux/v5.13/source/include/linux/bpf.h#L464">get_func_proto()</a>。func_proto 包含返回值和参数类型等信息，Verifier 据此对 eBPF 程序进行类型检查。</p>
<p>调用 helper 函数只需设置 BPF_CALL 的 imm 为 func_id。Verifier 在 <a href="https://elixir.bootlin.com/linux/v5.13/source/kernel/bpf/verifier.c#L12351">do_misc_fixups()</a> 时，将 imm 重写为对应 helper 函数相对 <a href="https://elixir.bootlin.com/linux/v5.13/source/include/linux/filter.h#L913">__bpf_call_base()</a> 的地址偏移。helper 函数地址也包含在 func_proto 中。</p>
<p>helper 函数地址通过相对偏移计算，然后：</p>
<ul>
<li>对于 JIT 编译器，发射 call 指令即可；</li>
<li>对于解释器，用 R1-R5 作为参数调用 helper 函数，返回值写入 R0。</li>
</ul>
<h4 id="tail-call"><a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=3f55b7ed5e5d4aa7291e3a1e2f7224eeba5810ba">tail call</a></h4>
<p>tail call 使用 BPF_CALL 指令，func_id 为 BPF_FUNC_tail_call，对应一个形式上的、没有具体实现的 helper 函数，接受三个参数：R1 为 ctx；R2 为指向 PROG_ARRAY 类型 map 的指针；R3 为 map 的索引，指示要调用的 eBPF 程序。Verifier 在 do_misc_fixups() 时将其 <a href="https://elixir.bootlin.com/linux/v5.13/source/kernel/bpf/verifier.c#L12513">替换为内部指令 BPF_TAIL_CALL</a>。</p>
<p>tail call 严格来说不算过程调用。它相当于一个到目标 eBPF 程序的无条件跳转，因此将复用当前栈帧，且不会返回到当前程序。如果索引越界，或目标程序为空，或 tail call 次数超过 32（<a href="https://elixir.bootlin.com/linux/v5.13/source/include/linux/bpf.h#L1015">MAX_TAIL_CALL_CNT</a>），tail call 将失败，此时程序会继续执行。</p>
<p>PROG_ARRAY 记录的是结构体 <a href="https://elixir.bootlin.com/linux/v5.13/source/include/linux/filter.h#L550">bpf_prog</a> 的地址：</p>
<ul>
<li>JIT 编译器从中取出 bpf_func，通过 <a href="../todo">retpoline</a>，即 <a href="https://elixir.bootlin.com/linux/v5.13/source/arch/x86/include/asm/nospec-branch.h#L328">RETPOLINE_RCX_BPF_JIT()</a> 宏跳转到该地址；</li>
<li>解释器从中取出 eBPF 指令序列，让 PC 指向第一条指令即可。</li>
</ul>
<p>因此，tail call 链上的程序要么都 JIT 编译执行，要么都解释执行，不能交替。调用链可以动态调整，修改 PROG_ARRAY 即可，在包处理 pipeline 这类场景中很有用。</p>
<h4 id="bpf2bpf-call"><a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=ef9fde06a259f5da660ada63214addf8cd86a7b9">bpf2bpf call</a></h4>
<p>bpf2bpf call 也使用 BPF_CALL 指令，设置 src_reg 为 <a href="https://elixir.bootlin.com/linux/v5.13/source/include/uapi/linux/bpf.h#L1141">BPF_PSEUDO_CALL</a>，imm 为到目标函数的指令偏移，其指向的 eBPF 指令即为函数起点。Verifier 按此将传入的 eBPF 程序分割为若干 subprog，主函数也包括在内，均通过 BPF_EXIT 返回。</p>
<p>Verifier 在 <a href="https://elixir.bootlin.com/linux/v5.13/source/kernel/bpf/verifier.c#L12277">fixup_call_args()</a> 时：</p>
<ol>
<li>调用 <a href="https://elixir.bootlin.com/linux/v5.13/source/kernel/bpf/verifier.c#L12034">jit_subprogs()</a>：<ol>
<li>单独编译每个 subprog，此时 bpf2bpf call 仍表示为 BPF_CALL 指令，JIT 编译器对其按 helper call 处理，即发射一条目标为__bpf_call_base() + imm 的 call 指令，imm 事先重写为 1；</li>
<li>如果 subprog 都编译成功，重写 bpf2bpf call 指令的 imm 为目标 image 相对 __bpf_call_base() 的地址偏移，再次调用 JIT 编译器，修正 call 的目标地址。</li>
</ol>
</li>
<li>调用 <a href="https://elixir.bootlin.com/linux/v5.13/source/kernel/bpf/core.c#L1756">bpf_patch_call_args()</a>，截断 imm 放入 off，重写 imm 为带参解释器 <a href="https://elixir.bootlin.com/linux/v5.13/source/kernel/bpf/core.c#L1748">interpreters_args</a> 相对 <a href="https://elixir.bootlin.com/linux/v5.13/source/include/linux/filter.h#L914">__bpf_call_base_args()</a> 的地址偏移，将 BPF_CALL 替换为内部指令 BPF_CALL_ARGS。</li>
</ol>
<p>BPF_CALL_ARGS 指令仅用于解释执行。bpf2bpf call 是标准的过程调用，需要新栈帧，有返回值，因此只更新 PC 是不行的。解释器将其转为 C 过程调用执行，对应 <a href="https://elixir.bootlin.com/linux/v5.13/source/kernel/bpf/core.c#L1522">JMP_CALL_ARGS</a> 标签：</p>
<pre><code class="language-c">JMP_CALL_ARGS:
    BPF_R0 = (__bpf_call_base_args + insn-&gt;imm)(BPF_R1, BPF_R2,
                                                BPF_R3, BPF_R4,
                                                BPF_R5,
                                                insn + insn-&gt;off + 1);
</code></pre>
<p>即调用带参解释器解释执行目标函数。因为要传递 R1-R5 五个参数，所以不能复用只传递 ctx 的 interpreters。但除此之外两者没有区别，都是调用 ___bpf_prog_run()。将 bpf2bpf call 实现为 C 过程调用可以简化解释器，弊端是不支持混用 bpf2bpf call 和 tail call，这样的 eBPF 程序只能 JIT 编译执行。</p>
<p>bpf2bpf call 有栈溢出的危险。Verifier 在 <a href="https://elixir.bootlin.com/linux/v5.13/source/kernel/bpf/verifier.c#L3596">check_max_stack_depth()</a> 进行检查：</p>
<ul>
<li>bpf2bpf call 最多嵌套 8 次（<a href="https://elixir.bootlin.com/linux/v5.13/source/include/linux/bpf_verifier.h#L218">MAX_CALL_FRAMES</a>），总栈深不能超过 512 字节（<a href="https://elixir.bootlin.com/linux/v5.13/source/include/linux/filter.h#L83">MAX_BPF_STACK</a>）；</li>
<li>tail call 时栈深不能超过 256 字节。tail call 最多 32 次，因此最多消耗 8K 栈空间。</li>
</ul>
<p>对用户来说，eBPF 编程是面向 C 的，没有 bpf2bpf call，函数照样能用，加上 always_inline 而已。bpf2bpf call 的主要意义是缩小 eBPF 程序体积，从而更快加载。</p>
<h3 id="_8">用户空间接口</h3>
<p>用户空间通过系统调用 <a href="https://elixir.bootlin.com/linux/v5.13/source/kernel/bpf/syscall.c#L4369">bpf()</a> 操作 eBPF 程序/map。在 bpf() 的基础上封装了更易于使用的 <a href="https://elixir.bootlin.com/linux/v5.13/source/tools/lib/bpf">libbpf</a>。<a href="https://elixir.bootlin.com/linux/v5.13/source/samples/bpf/sock_example.c#L35">sock_example</a> 用 eBPF 进行数据包统计：</p>
<ol>
<li><a href="https://elixir.bootlin.com/linux/v5.13/source/tools/lib/bpf/bpf.c#L128">bpf_create_map()</a> 创建 map；</li>
<li>使用 <a href="https://elixir.bootlin.com/linux/v5.13/source/tools/include/linux/filter.h#L34">指令宏</a> 编写 eBPF 程序，负责在 map 中更新统计信息；</li>
<li><a href="https://elixir.bootlin.com/linux/v5.13/source/tools/lib/bpf/bpf.c#L369">bpf_load_program()</a> 加载该程序；</li>
<li>setsockopt() 附加该程序到 lo 网卡；</li>
<li><a href="https://elixir.bootlin.com/linux/v5.13/source/tools/lib/bpf/bpf.c#L424">bpf_map_lookup_elem()</a> 查询 map，得到统计信息。</li>
</ol>
<p>与指令宏相比，用高级语言编写 eBPF 程序更友好。LLVM 已有完善的 eBPF 后端，可以从 C 生成 <a href="../todo">ELF 格式</a> 的目标文件，其中包含 eBPF 程序和 map 信息等。libbpf 能解析该目标文件，完成所需 map 的创建以及 eBPF 程序的加载。</p>
<h3 id="verifier">Verifier</h3>
<p>eBPF 程序运行在内核态，加载到内核时调用 <a href="https://elixir.bootlin.com/linux/v5.13/source/kernel/bpf/verifier.c#L13358">bpf_check()</a>，即 Verifier 验证其安全性：</p>
<ol>
<li>解析 subprog，通过 <a href="https://elixir.bootlin.com/linux/v5.13/source/kernel/bpf/verifier.c#L1545">add_subprog()</a> 记录；</li>
<li><a href="https://elixir.bootlin.com/linux/v5.13/source/kernel/bpf/verifier.c#L1776">check_subprogs()</a>：跳转不能超出当前 subprog，每个 subprog 必须以 BPF_EXIT 或无条件跳转结尾；</li>
<li>resolve_pseudo_ldimm64() 解析 <a href="https://elixir.bootlin.com/linux/v5.13/source/include/linux/filter.h#L187">BPF_LD_IMM64_RAW</a> 指令，重写 map fd 等为具体地址；</li>
<li><a href="https://elixir.bootlin.com/linux/v5.13/source/kernel/bpf/verifier.c#L9406">check_cfg()</a>：DFS，所有指令都要可达；</li>
<li><a href="https://elixir.bootlin.com/linux/v5.13/source/kernel/bpf/verifier.c#L12909">do_check_main()</a> -&gt; <a href="https://elixir.bootlin.com/linux/v5.13/source/kernel/bpf/verifier.c#L12785">do_check_common()</a> -&gt; <a href="https://elixir.bootlin.com/linux/v5.13/source/kernel/bpf/verifier.c#L10594">do_check()</a>：依次检查主函数的每条指令：<ul>
<li>指令各字段必须合法，总数不能超过 100 万（<a href="https://elixir.bootlin.com/linux/v5.13/source/include/linux/bpf.h#L1014">BPF_COMPLEXITY_LIMIT_INSNS</a>）；</li>
<li><a href="https://elixir.bootlin.com/linux/v5.13/source/kernel/bpf/verifier.c#L5956">check_helper_call()</a>，<a href="https://elixir.bootlin.com/linux/v5.13/source/kernel/bpf/verifier.c#L5698">check_func_call()</a>：过程调用必须合法；</li>
<li><a href="https://elixir.bootlin.com/linux/v5.13/source/kernel/bpf/verifier.c#L4060">check_mem_access()</a>：目标内存必须可访问。</li>
</ul>
</li>
<li>check_max_stack_depth()：检查 bpf2bpf call 的栈深；</li>
<li>do_misc_fixups() 重写 func_id，处理 tail call 等；</li>
<li>fixup_call_args()：处理 bpf2bpf call。</li>
</ol>
                
              
              
                


              
            </article>
          </div>
        </div>
        
      </main>
      
        
<footer class="md-footer">
  
    <nav class="md-footer__inner md-grid" aria-label="Footer">
      
        
        <a href=".." class="md-footer__link md-footer__link--prev" aria-label="Previous: " rel="prev">
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
          </div>
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                Previous
              </span>
              
            </div>
          </div>
        </a>
      
      
        
        <a href="../kernel-debugging-qemu-busybox-gdb/" class="md-footer__link md-footer__link--next" aria-label="Next: gdb 调试内核" rel="next">
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                Next
              </span>
              gdb 调试内核
            </div>
          </div>
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4z"/></svg>
          </div>
        </a>
      
    </nav>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        Made with
        <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
          Material for MkDocs
        </a>
        
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    <script id="__config" type="application/json">{"base": "..", "features": [], "translations": {"clipboard.copy": "Copy to clipboard", "clipboard.copied": "Copied to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.placeholder": "Type to start searching", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.term.missing": "Missing", "select.version.title": "Select version"}, "search": "../assets/javascripts/workers/search.409db549.min.js", "version": null}</script>
    
    
      <script src="../assets/javascripts/bundle.756773cc.min.js"></script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.min.js"></script>
      
        <script src="../javascripts/config.js"></script>
      
    
  </body>
</html>